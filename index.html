<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BLE ç”µå­çº¸</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      background: #f9f9f9;
    }

    label {
      display: inline-block;
      /* å¿…é¡»è®¾ç½®ï¼Œå¦åˆ™ width æ— æ•ˆ */
      width: 100px;
      /* æ ¹æ®ä½ æœ€é•¿çš„æ–‡å­—ï¼ˆæ¯”å¦‚ Model Nameï¼‰æ¥å®šå®½åº¦ */
      text-align: right;
      /* æ–‡å­—é å³å¯¹é½ï¼Œæ˜¾å¾—ä¸“ä¸š */
      margin-right: 15px;
      /* è§£å†³ä½ æåˆ°çš„ï¼šinput ç¦»æ–‡å­—å¤ªè¿‘çš„é—®é¢˜ */
    }

    input {
      margin-left: 10px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 100%;
      max-width: 100px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 10px 5px;
      margin-left: auto;
      cursor: pointer;

      background-color: #007BFF;
      color: white;
      border: none;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;

      /* å½“é¼ æ ‡æ‚¬åœåœ¨æŒ‰é’®ä¸Šæ—¶æ”¹å˜èƒŒæ™¯é¢œè‰² */
      &:hover {
        background-color: #0056b3;
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      }

      /* å½“æŒ‰é’®è¢«æŒ‰ä¸‹æ—¶ */
      &:active {
        transform: translateY(1px);
        /* æ¨¡æ‹ŸæŒ‰ä¸‹çš„æ•ˆæœ */
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
      }
    }

    .control-group {
      border: 2px solid #e5e5e5;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
      background-color: #f9f9f9;
    }

    .row {
      display: flex;
      /* å¼€å¯å¼¹æ€§å¸ƒå±€ */
      align-items: center;
      /* å‚ç›´å±…ä¸­å¯¹é½ */
      margin-bottom: 15px;
      /* æ¯è¡Œä¹‹é—´çš„é—´è· */
    }

    .preview-box {
      width: 380px;
      height: 300px;
      border: 2px dashed #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .preview-box img {
      max-width: 100%;
      max-height: 100%;
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      margin: auto;
    }

    .preview-box .placeholder {
      color: #999;
      pointer-events: none;
    }

    @media (max-width: 640px) {
      #imagePreviewsContainer {
        flex-direction: column;
        align-items: center;
      }
    }

    /* è°ƒè‰²æ¿é¢œè‰²å—åŸºç¡€æ ·å¼åŠé€‰ä¸­çŠ¶æ€ */
    .palette-item {
      width: 24px;
      height: 24px;
      border: 2px solid #ccc;
      cursor: pointer;
      border-radius: 4px;
      transition: transform 0.2s, border-color 0.2s;
    }

    .palette-item:hover {
      transform: scale(1.1);
    }

    .palette-item.selected {
      border-color: #007BFF;
      /* é€‰ä¸­æ—¶æ˜¾ç¤ºè“è‰²é«˜äº®è¾¹æ¡† */
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      outline: 2px solid #007BFF;
    }

    #status {
      margin-top: 20px;
      padding: 10px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      min-height: 50px;

      max-height: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      font-size: 12px;
    }

    #imagePreviewsContainer {
      display: flex;
      gap: 16px;
      /* ä¸¤ä¸ªé¢„è§ˆæ¡†ä¹‹é—´çš„é—´è· */
      margin: 10px 0;
      flex-wrap: wrap;
      /* å…è®¸åœ¨çª„å±æ—¶æ¢è¡Œ */
      justify-content: center;
    }
  </style>
</head>

<body>
  <h1>YES-LCDxNewFace: Web BLE ç”µå­çº¸</h1>

  <div id="bleInfo" class="control-group">
    <form>
      <div class="row">
        <label for="allDevices">All Devices</label>
        <input id="allDevices" type="checkbox">
        <input id="service" type="text" size=17 list="services" placeholder="Bluetooth Service" value="0x00FF"
          hidden=true>
        <input id="characteristic" type="text" size=17 list="services" placeholder="Bluetooth Characteristic"
          hidden=true>
        <input id="name" type="text" size=17 placeholder="Device Name" hidden=true>
        <input id="namePrefix" type="text" size=17 placeholder="Device Name Prefix" value="YES">
        <button id="scanBLEBtn">Scan BLE Device</button>
      </div>
    </form>
  </div>

  <br>
  <div id="wifiInfo" class="control-group">
    <div class="row">
      <label>SSID:</label>
      <input id="ssid" type="text" value="Outside">
      <label>Password:</label>
      <input id="password" type="text" value="yeslcd123">
      <button id="setWifiBtn">Set WiFi</button>
    </div>
    <div class="row">
      <lable>IP: </lable>
      <input id="ipAddress" type="text" readonly>
      <button id="getIPBtn">Get IP</button>
    </div>
  </div>

  <br>
  <div id="setdevice" class="control-group">
    <div class="row">
      <label>Model Name: </label>
      <input id="modelSet" type="text">
      <button id="setdeviceBtn">Set Device</button>
    </div>
    <div class="row">
      <label>å·¥ä½œæ¨¡å¼:</label>
      <select id="woringModeSet">
        <option value="0">0: æ­£å¸¸æ¨¡å¼</option>
        <option value="1">1: ç›¸å†Œæ¨¡å¼</option>
      </select>
      <button id="setModeBtn">Set Mode</button>
    </div>
  </div>

  <br>
  <div id="deviceInfo" class="control-group">
    <div class="row">
      <label>å‹å·:</label>
      <input id="modelGet" type="text" readonly>
      <button id="getinfobtn">Get Info</button>
    </div>
    <div class="row">
      <label>å®½:</label>
      <input id="width" type="text" readonly>
      <label>é«˜:</label>
      <input id="height" type="text" readonly>
      <label>BPP:</label>
      <input id="BPP" type="text" readonly>
    </div>
    <div class="row">
      <label>è°ƒè‰²æ¿:</label>
      <span id="paletteContainer" style="display: inline-flex; gap: 5px; margin-left: 10px;">
        <div style="width: 20px; height: 20px; background-color: #FF0000;"></div>
        <div style="width: 20px; height: 20px; background-color: #00FF00;"></div>
        <div style="width: 20px; height: 20px; background-color: #0000FF;"></div>
        <div style="width: 20px; height: 20px; background-color: #FFFFFF;"></div>
        <div style="width: 20px; height: 20px; background-color: #000000;"></div>
      </span>
      <button id="ClearBtn">Clear Screen</button>
    </div>
  </div>

  <div id="imagePreviewsContainer">
    <!-- åŸå›¾é¢„è§ˆ -->
    <div class="preview-box">
      <span class="placeholder">ğŸ“· åŸå›¾</span>
      <img id="previewImage" src="" alt="åŸå›¾">
    </div>

    <!-- é‡åŒ–å›¾é¢„è§ˆ -->
    <div class="preview-box">
      <span class="placeholder">ğŸ“Š é‡åŒ–å›¾</span>
      <img id="quantizedImage" src="" alt="é‡åŒ–å›¾">
    </div>

    <input type="file" id="imageInput" accept="image/*" style="display: none;">
  </div>


  <div style="margin-top: 10px;" class="control-group">
    <button id="exportBinBtn">Export Bin</button>
    <button id="importBinBtn">Import Bin</button>
    <input type="file" id="fileInput" style="display: none;" accept=".bin">
    <button id="quantizedImagebtn">Quantized Image</button>
  </div>

  <button id="sendBtnBle">Send Image (Bluetooth)</button>
  <button id="sendBtnIP">Send Image (IP)</button>


  <div id="status">çŠ¶æ€ï¼šç­‰å¾…æ“ä½œ...</div>


  <script src="libs/RgbQuant/src/rgbquant.js"></script>
  <script>
    const EPD_CMD = {
      CMD_RESET_EPD: 0x00, //reset epd
      CMD_SET_EPD_NAME: 0x01, //set epd name, 0x01, name_len, name
      CMD_REPORT_EPD_INFO: 0x02, //report epd info at next read
      CMD_START_WRITE_DATA: 0x03, //start to write data, 4byte means data len
      CMD_CURRENT_PACKET_INDEX: 0x04, //current packet index and data
      CMD_END_WRITE_DATA: 0x05, //end of write data
      CMD_EPD_CLEAR: 0x06, //clear epd screen
      CMD_BATTERY_LEVEL: 0x07, //battery level, 2byte 10mV per bit, 65535*10mV=655.35V Max
      CMD_SET_WIFI: 0x08, //set wifi ssid and password, 0x08, ssid_len, ssid, pwd_len, pwd
      CMD_SET_WORKING_MODE: 0x09, //show qrcode on image, 1byte, 0:off, 1:on
    };

    let LUT_DATA = null;

    let deviceConfig = [];
    let outputData = null;

    let bleState = {
      connected: false,
      device: null,
      server: null,
      service: null,
      characteristics: null,
      ch_tx: null, // FF05: å†™æŒ‡ä»¤
      ch_rx: null, // FF04: è¯»æ•°æ®
      ch_status: null, // FF01: æ¥æ”¶é€šçŸ¥/æŒ‡ç¤º (Notify/Indicate)
    };

    let selectedPaletteIndex = 0; // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ªé¢œè‰²ï¼ˆé€šå¸¸æ˜¯èƒŒæ™¯è‰²ï¼‰

    function log(...args) {
      const statusDiv = document.getElementById('status');

      // ç”Ÿæˆæ ¼å¼åŒ–æ—¶é—´æˆ³ [HH:mm:ss.SSS]
      const now = new Date();
      const h = String(now.getHours()).padStart(2, '0');
      const m = String(now.getMinutes()).padStart(2, '0');
      const s = String(now.getSeconds()).padStart(2, '0');
      const ms = String(now.getMilliseconds()).padStart(3, '0');
      const timestamp = `[ ${h}:${m}:${s}.${ms}]`; // â† è¿™é‡Œæ²¡æœ‰å¤šä½™ç©ºæ ¼ï¼

      // å®‰å…¨è½¬æ¢å‚æ•°ï¼ˆé¿å…å¾ªç¯å¼•ç”¨å¯¼è‡´çš„é”™è¯¯ï¼‰
      const message = args.map(arg => {
        try {
          return typeof arg === 'object' && arg !== null
            ? JSON.stringify(arg, null, 2)
            : String(arg);
        } catch (e) {
          return `[Unserializable Object: ${e.message}]`;
        }
      }).join(' ');

      const fullMessage = ` ${timestamp} ${message}`;

      if (statusDiv) {
        const line = document.createElement('div');
        line.textContent = fullMessage;
        line.style.fontFamily = 'monospace'; // æå‡æ—¶é—´æˆ³å¯è¯»æ€§
        line.style.fontSize = '0.95em';
        statusDiv.appendChild(line);
        statusDiv.scrollTop = statusDiv.scrollHeight; // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
      } else {
        // å›é€€åˆ°æ§åˆ¶å°ï¼ˆåŒæ ·å¸¦æ—¶é—´æˆ³ï¼Œä¾¿äºè°ƒè¯•ï¼‰
        console.log(fullMessage);
        console.warn('æœªæ‰¾åˆ° #status å…ƒç´ ï¼Œæ—¥å¿—å·²è¾“å‡ºåˆ°æ§åˆ¶å°');
      }
    }

    const withTimeout = (promise, ms, name) => {
      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error(`Timeout: ${name} (${ms}ms)`)), ms)
      );
      return Promise.race([promise, timeout]);
    };

    function isWebBluetoothEnabled() {
      if (navigator.bluetooth) {
        return true;
      } else {
        console.log('Web Bluetooth API is not available.\n' +
          'Please make sure the "Experimental Web Platform features" flag is enabled.');
        return false;
      }
    }

    function printCharPermissions(char, name) {
      const props = char.properties;
      log(`\n--- ${name} (${char.uuid}) ---`);
      log('Readable: ', props.read);
      log('Writable (req):', props.write);
      log('Writable (cmd):', props.writeWithoutResponse);
      log('Notifiable: ', props.notify);
      log('Indicatable: ', props.indicate);
    }

    function convertImageToBytes(img) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;

      ctx.drawImage(img, 0, 0);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const rgbaData = imageData.data; // Uint8ClampedArray

      const rgbData = new Uint8Array(rgbaData.length / 4 * 3);
      let j = 0;
      for (let i = 0; i < rgbaData.length; i += 4) {
        rgbData[j++] = rgbaData[i];     // R
        rgbData[j++] = rgbaData[i + 1]; // G
        rgbData[j++] = rgbaData[i + 2]; // B
        // è·³è¿‡ Alpha: rgbaData[i + 3]
      }

      return rgbData;
    }

    async function startBle() {
      let filters = [];

      let serviceUuid = document.querySelector('#service').value;
      if (serviceUuid.startsWith('0x')) {
        serviceUuid = parseInt(serviceUuid);
      }

      let characteristicUuid = document.querySelector('#characteristic').value;
      if (characteristicUuid.startsWith('0x')) {
        characteristicUuid = parseInt(characteristicUuid);
      }

      let filterService = document.querySelector('#service').value;

      if (filterService.startsWith('0x')) {
        filterService = parseInt(filterService);
      }
      if (filterService) {
        filters.push({ services: [filterService] });
      }

      let filterName = document.querySelector('#name').value;
      if (filterName) {
        filters.push({ name: filterName });
      }

      let filterNamePrefix = document.querySelector('#namePrefix').value;
      if (filterNamePrefix) {
        filters.push({ namePrefix: filterNamePrefix });
      }

      let options = {};
      if (document.querySelector('#allDevices').checked) {
        options.acceptAllDevices = true;
      } else {
        options.filters = filters;
      }

      try {

        log('Requesting Bluetooth Device...');
        log('with ' + JSON.stringify(options));
        bleState.device = await navigator.bluetooth.requestDevice(options)

        // ç›‘å¬æ–­å¼€äº‹ä»¶ï¼ˆéå¸¸é‡è¦ï¼å¦‚æœç¡¬ä»¶åœ¨è¿æ¥ç¬é—´æ–­å¼€ï¼Œè¿™é‡Œèƒ½æ•è·ï¼‰
        bleState.device.addEventListener(' gattserverdisconnected', () => {
          log('âš ï¸ è“ç‰™è¿æ¥æ„å¤–æ–­å¼€ï¼');
        });

        log('Connecting to GATT Server...');
        bleState.server = await withTimeout(bleState.device.gatt.connect(), 25000, 'GATTè¿æ¥');

        log('Getting Service...');
        bleState.service = await withTimeout(bleState.server.getPrimaryService(serviceUuid), 25000, 'æœåŠ¡è·å–');

        log('Getting Characteristics...');
        bleState.characteristics = await withTimeout(bleState.service.getCharacteristics(), 5000, 'ç‰¹å¾è·å–');

        log('> Characteristics: ' +
          bleState.characteristics.map(c => c.uuid).join('\n' + ' '.repeat(19)));

        bleState.ch_tx = await bleState.service.getCharacteristic(0xFF05); // å†™
        bleState.ch_rx = await bleState.service.getCharacteristic(0xFF04); // è¯»
        bleState.ch_status = await bleState.service.getCharacteristic(0xFF01); // æ¥æ”¶ç»“æœåé¦ˆ
        console.log("Status ç‰¹æ€§ UUID:", bleState.ch_status.uuid);

        await withTimeout(bleState.ch_status.startNotifications(), 5000, 'é€šçŸ¥å¯åŠ¨');
        bleState.ch_status.addEventListener('characteristicvaluechanged', handleStatusUpdate);
        log("âœ… æ‰€æœ‰è“ç‰™é€šé“åˆå§‹åŒ–å®Œæˆ (FF01, FF04, FF05)");

        try {
          const payload = new Uint8Array(1);
          payload[0] = EPD_CMD.CMD_REPORT_EPD_INFO;

          await bleState.ch_tx.writeValueWithResponse(payload);
          log("âœ… å‘é€æˆåŠŸ");
        } catch (error) {
          log(`âŒ å‘é€å¤±è´¥: ${error}`);
          console.error(error);
        }

        const value = await withTimeout(bleState.ch_rx.readValue(), 5000, 'FF04 è¯»å–');
        log('Char FF04 value: ' + value);

        const bytes = new Uint8Array(value.buffer);
        log(`âœ… FF04 è¯»å–æˆåŠŸï¼Œå…± ${bytes.length} å­—èŠ‚:`);
        log('æ•°æ®ï¼ˆåå…­è¿›åˆ¶ï¼‰:', bytes.map(b => b.toString(16).padStart(2, '0')).join(' '));

        try {
          const jsonString = new TextDecoder().decode(value);
          log('æ•°æ®ï¼ˆJSON æ–‡æœ¬ï¼‰:', `"${jsonString}"`);

          // å¯é€‰ï¼šè§£æä¸º JS å¯¹è±¡å¹¶ç¾åŒ–æ‰“å°
          const jsonObj = JSON.parse(jsonString);
          log('æ•°æ®ï¼ˆè§£æåå¯¹è±¡ï¼‰:', JSON.stringify(jsonObj, null, 2));

          if (jsonObj.palette) {
            devicePalette = jsonObj.palette.split(';').map(c => c.split(',').map(Number));
          }

          document.getElementById('modelGet').value = jsonObj.name || "æœªçŸ¥";
          document.getElementById('width').value = jsonObj.width || 0;
          document.getElementById('height').value = jsonObj.height || 0;
          document.getElementById('BPP').value = jsonObj.bpp || 0;

          // 2. å¤„ç†å¹¶æ¸²æŸ“è°ƒè‰²æ¿
          const paletteContainer = document.getElementById('paletteContainer');
          if (paletteContainer && jsonObj.palette) {
            // æ¸…ç©ºæ—§çš„é¢œè‰²æ–¹å—
            paletteContainer.innerHTML = '';

            // è§£æè°ƒè‰²æ¿å­—ç¬¦ä¸² "0,0,0;255,255,255;..."
            const colors = jsonObj.palette.split(';');

            colors.forEach((colorRgb, index) => {
              const colorBox = document.createElement('div');
              colorBox.className = 'palette-item'; // ä½¿ç”¨æ–°æ ·å¼
              colorBox.style.backgroundColor = `rgb(${colorRgb})`;
              colorBox.dataset.index = index; // å­˜å‚¨ç´¢å¼•

              // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
              if (index === selectedPaletteIndex) {
                colorBox.classList.add('selected');
              }

              // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼šæ¨¡æ‹Ÿå•é€‰æŒ‰é’®è¡Œä¸º
              colorBox.onclick = () => {
                document.querySelectorAll('.palette-item').forEach(el => el.classList.remove('selected'));
                colorBox.classList.add('selected');
                selectedPaletteIndex = index; // æ›´æ–°å…¨å±€é€‰ä¸­çš„ç´¢å¼•
                log(`å·²é€‰ä¸­è°ƒè‰²æ¿é¢œè‰²ç´¢å¼•: ${index}`);
              };

              // æ·»åŠ åˆ°å®¹å™¨ä¸­
              paletteContainer.appendChild(colorBox);
            });
          }

          log('âœ… UI ä¿¡æ¯æ›´æ–°å®Œæˆ');
        } catch (e) {
          log('âš ï¸ æ•°æ®ä¸æ˜¯æœ‰æ•ˆ JSON:', e.message);
        }
      }
      catch (error) {
        log('âŒ é”™è¯¯: ' + error.message);

        alert("è·å–è®¾å¤‡ä¿¡æ¯å¤±è´¥ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªå…¨æ–°è®¾å¤‡, è¯·å…ˆè®¾ç½®è®¾å¤‡å‹å·, æˆ–è€…è¿æ¥ä¸­æ–­è¯·é‡è¯•");
      };
    }

    function handleStatusUpdate(event) {
      const value = event.target.value;
      // å‡è®¾ ESP32 åœ¨ä¿å­˜æˆåŠŸåå‘é€ 0x01ï¼Œå¤±è´¥å‘é€ 0x00
      const status = value.getUint8(0);

      if (status === 0x81) {
        log("ğŸ¯ ç¡¬ä»¶åé¦ˆ: å‹å·è®¾ç½®æˆåŠŸå¹¶å·²ä¿å­˜åˆ° NVS");
        // è¿™é‡Œå¯ä»¥æ‰§è¡Œ UI å˜ç»¿ç­‰æ“ä½œ
      } else if (status === 0x8F) {
        log("âŒ ç¡¬ä»¶åé¦ˆ: å‹å·è®¾ç½®å¤±è´¥ (å‹å·æ— æ•ˆ)");
      } else {
        log(`ğŸ“¡ æ”¶åˆ°æœªçŸ¥çŠ¶æ€ç : 0x${status.toString(16)}`);
      }
    }

    // å°è£…åŠ è½½é€»è¾‘
    async function loadLUT() {
      try {
        const res = await fetch('lut/Spectra6_Render_LUT_Default_v2.bin');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        LUT_DATA = await res.arrayBuffer();

        const view = new Uint8Array(LUT_DATA);
        const head = Array.from(view.slice(0, 18)).map(b => b.toString(16).padStart(2, '0')).join(' ');
        log('âœ… LUT åŠ è½½æˆåŠŸ | å¤§å°:', LUT_DATA.byteLength, 'å­—èŠ‚ | å‰18å­—èŠ‚:', head);
      } catch (err) {
        log('LUT åŠ è½½é”™è¯¯:', err);
      }
    }

    // é¡µé¢ DOM å°±ç»ªåè‡ªåŠ¨è§¦å‘
    document.addEventListener('DOMContentLoaded', () => {
      loadLUT();
    });


    document.getElementById('sendBtnBle').addEventListener('click', async () => {
      if (!outputData || outputData.length === 0) {
        alert("è¯·å…ˆè¿›è¡Œå›¾ç‰‡é‡åŒ–ï¼Œç”Ÿæˆè¾“å‡ºæ•°æ®ï¼");
        return;
      }

      if (!bleState.ch_tx) {
        alert("è“ç‰™æœªè¿æ¥æˆ–å†™å…¥ç‰¹æ€§ä¸å¯ç”¨ï¼");
        return;
      }

      const CHUNK_SIZE = 490; // æ¯ä¸ªåŒ…åŒ…å«çš„å›¾åƒæ•°æ®é•¿åº¦
      const totalPackets = Math.ceil(outputData.length / CHUNK_SIZE);
      const totalBytes = outputData.length;
      log(`å¼€å§‹å‘é€æ•°æ®ï¼Œæ€»è®¡ ${outputData.length} å­—èŠ‚ï¼Œåˆ†ä¸º ${totalPackets} ä¸ªåŒ…...`);
      log(`ğŸ“¡ å‘é€å¼€å§‹æŒ‡ä»¤: æ€»å¤§å° ${totalBytes} å­—èŠ‚`);

      try {
        const startCmd = new Uint8Array(5);
        startCmd[0] = 0x03;
        startCmd[1] = (totalBytes >> 24) & 0xFF;
        startCmd[2] = (totalBytes >> 16) & 0xFF;
        startCmd[3] = (totalBytes >> 8) & 0xFF;
        startCmd[4] = totalBytes & 0xFF;

        log(`ğŸ“¡ å‘é€å¼€å§‹æŒ‡ä»¤: æ€»å¤§å° ${totalBytes} å­—èŠ‚`);
        await bleState.ch_tx.writeValue(startCmd);

        //time.sleep(0.05);

        for (let i = 0; i < totalPackets; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, totalBytes);
          const actualPayloadLen = end - start; // æœ€åä¸€åŒ…å¯èƒ½å°äº 490

          const packet = new Uint8Array(5 + actualPayloadLen);
          packet[0] = 0x04;
          packet[1] = (i >> 24) & 0xFF;
          packet[2] = (i >> 16) & 0xFF;
          packet[3] = (i >> 8) & 0xFF;
          packet[4] = i & 0xFF;

          // 4. å¡«å……æ¥ä¸‹æ¥çš„ 490 å­—èŠ‚å›¾åƒæ•°æ®
          const chunk = outputData.slice(start, end);
          packet.set(chunk, 5);

          // 5. é€šè¿‡è“ç‰™å‘é€ (ä½¿ç”¨ writeValue æˆ– writeValueWithResponse)
          // æ³¨æ„ï¼šå¦‚æœè®¾å¤‡æ”¯æŒï¼Œå»ºè®®ä½¿ç”¨ writeValueWithResponse ç¡®ä¿æ•°æ®åˆ°è¾¾
          //await bleState.ch_tx.writeValue(packet);
          await bleState.ch_tx.writeValueWithResponse(packet);

          // 6. æ›´æ–°è¿›åº¦ (å¯é€‰)
          if (i % 10 === 0 || i === totalPackets - 1) {
            const progress = ((i + 1) / totalPackets * 100).toFixed(1);
            log(`è¿›åº¦: ${progress}% (${i + 1}/${totalPackets})`);
          }

          // ğŸ’¡ å¦‚æœå‘é€è¿‡å¿«å¯¼è‡´ä¸¢åŒ…ï¼Œå¯ä»¥åŠ ä¸€ä¸ªå¾®å°çš„å»¶è¿Ÿ
          // await new Promise(resolve => setTimeout(resolve, 10));
        }

        const endCmd = new Uint8Array([0x05]);
        log("ğŸ“¡ å‘é€ç»“æŸæŒ‡ä»¤");
        await bleState.ch_tx.writeValue(endCmd);

        log("âœ… æ‰€æœ‰æ•°æ®åŒ…å‘é€å®Œæˆï¼");
        alert("ä¼ è¾“æˆåŠŸï¼");

      } catch (error) {
        log(`âŒ å‘é€å¤±è´¥: ${error.message}`);
        console.error(error);
        alert("ä¼ è¾“ä¸­æ–­ï¼Œè¯·æ£€æŸ¥è“ç‰™è¿æ¥");
      }
    });

    document.getElementById('quantizedImagebtn').addEventListener('click', async () => {
      // 1. è·å–è®¾å¤‡è¦æ±‚çš„å®½é«˜
      const targetWidth = parseInt(document.getElementById('width').value);
      const targetHeight = parseInt(document.getElementById('height').value);

      if (!targetWidth || !targetHeight || devicePalette.length === 0) {
        alert("è¯·å…ˆè¯»å–è®¾å¤‡ä¿¡æ¯"); return;
      }

      const img = document.getElementById('previewImage');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

      // è·å–å®Œæ•´çš„ ImageData å¯¹è±¡
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // 2. åˆå§‹åŒ– RgbQuant
      const rgbquant = new RgbQuant({
        colors: devicePalette.length,
        palette: devicePalette,

        reIndex: false, // å¿…é¡»ä¸º false ä»¥å¯¹åº”ä½ çš„ç¡¬ä»¶ç´¢å¼•
        method: 1, // å¼ºè¡Œå…¨å±€é‡åŒ–
        dithKern: "Stucki",
        dithDelta: 0, // è®¾ä¸º 0ï¼Œå¼ºåˆ¶æ‰€æœ‰åœ°æ–¹éƒ½å‚ä¸æŠ–åŠ¨å‡‘è‰²
        dithSerp: true, // å¼€å¯è›‡å½¢æ‰«æï¼Œæ··åˆæ›´å‡åŒ€
        useCache: false // å…³é—­ç¼“å­˜ï¼Œè®©æ¯ä¸ªåƒç´ éƒ½ç²¾ç¡®è®¡ç®—è·ç¦»
      });

      // ã€é‡è¦ä¿®æ­£ã€‘ç›´æ¥ä¼ å…¥ imageData å¯¹è±¡ï¼Œè·å–åƒç´ ç´¢å¼•æ•°ç»„
      // æ­¤æ—¶ indexData.length ç†è®ºä¸Šåº”ç­‰äº targetWidth * targetHeight
      const indexData = rgbquant.reduce(imageData, 2);
      // ğŸ” æ‰“å°å…³é”®ä¿¡æ¯è¿›è¡Œæ ¸å¯¹
      console.log("--- åŸå§‹ç´¢å¼•æ•°æ®æ’æŸ¥ ---");
      console.log("é¢„æœŸåƒç´ æ€»æ•° (W*H):", targetWidth * targetHeight);
      console.log("å®é™… indexData é•¿åº¦:", indexData.length);
      console.log("å‰ 10 ä¸ªåƒç´ çš„ç´¢å¼•å€¼:", indexData.slice(0, 10));

      if (indexData.length !== targetWidth * targetWidth) {
        console.error("âŒ è­¦å‘Šï¼šç´¢å¼•æ•°ç»„é•¿åº¦ä¸åˆ†è¾¨ç‡ä¸åŒ¹é…ï¼å¯èƒ½æ˜¯ RgbQuant é…ç½®æˆ–åŸå›¾å°ºå¯¸é—®é¢˜ã€‚");
      }


      const pixelCount = targetWidth * targetHeight;
      const colorCount = devicePalette.length;
      let packedData;

      console.log(`åƒç´ æ€»æ•°(W*H): ${pixelCount}`);
      console.log(`ç´¢å¼•æ•°ç»„é•¿åº¦: ${indexData.length}`);

      // 3. ä¸¥æ ¼æŒ‰åƒç´ æ€»æ•°è¿›è¡Œæ‰“åŒ…é€»è¾‘
      if (colorCount <= 2) { // ã€1bppã€‘ 8åƒç´  -> 1å­—èŠ‚
        packedData = new Uint8Array(Math.ceil(pixelCount / 8));
        for (let i = 0; i < pixelCount; i++) {
          const val = indexData[i] & 0x01; const byteIdx = Math.floor(i / 8); const
            bitShift = 7 - (i % 8); packedData[byteIdx] |= (val << bitShift);
        }
      }
      else if (colorCount <= 4) {
        const w = 1304; // å¼ºåˆ¶å›ºå®šå®½åº¦ï¼Œç¡®ä¿æ­¥è¿›ä¸€è‡´
        const h = 984;
        const stride = w / 4; // æ¯è¡Œä¸¥æ ¼ 326 å­—èŠ‚

        packedData = new Uint8Array(stride * h);

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            // è®¡ç®—åœ¨åŸå§‹åƒç´ æ•°ç»„ä¸­çš„ç´¢å¼• (å‡è®¾ indexData æ˜¯ w*h é•¿åº¦)
            const pixelIdx = y * w + x;
            let val = (indexData[pixelIdx] !== undefined) ? (indexData[pixelIdx] & 0x03) : 0;

            // ä¸‰è‰²å±æ˜ å°„é€»è¾‘ï¼šå¦‚æœç´¢å¼•æ˜¯2ï¼ˆé€šå¸¸æ˜¯çº¢è‰²ï¼‰ï¼Œæ˜ å°„ä¸º3ï¼ˆç¡¬ä»¶ä¸Šçš„çº¢è‰²ä½ï¼‰
            if (colorCount === 3 && val === 2) val = 3;

            // è®¡ç®—ç›®æ ‡å­—èŠ‚ä½ç½®ï¼šè¡Œåç§» + åˆ—åç§»
            const byteIdx = y * stride + Math.floor(x / 4);

            // å…³é”®ï¼šç¬¬ä¸€ä¸ªåƒç´ åœ¨æœ€é«˜ä½ (Bit 7-6)
            const bitShift = (3 - (x % 4)) * 2;

            // åˆå§‹åŒ–å­—èŠ‚ï¼ˆä»…åœ¨å¤„ç†æ¯ç»„4ä¸ªåƒç´ çš„ç¬¬ä¸€ä¸ªæ—¶ï¼‰
            if (x % 4 === 0) packedData[byteIdx] = 0;

            // æŒ‰ä½å‹å…¥
            packedData[byteIdx] |= (val << bitShift);
          }
        }
      }
      else {
        // ã€4bppã€‘ 2åƒç´  -> 1å­—èŠ‚
        packedData = new Uint8Array(Math.ceil(pixelCount / 2));
        for (let i = 0; i < pixelCount; i++) {
          const val = indexData[i] & 0x0F;
          const byteIdx = Math.floor(i / 2);
          const bitShift = (1 - (i % 2)) * 4; // 4, 0
          packedData[byteIdx] |= (val << bitShift);
        }
      }

      // 4. æ›´æ–°å…¨å±€å˜é‡å¹¶è¾“å‡ºç»“æœ
      outputData = packedData;
      console.log(`âœ… æ‰“åŒ…æˆåŠŸ! æœ€ç»ˆè¾“å‡ºé•¿åº¦: ${outputData.length} å­—èŠ‚`);

      // UI é¢„è§ˆ
      const visualData = rgbquant.reduce(imageData);
      imageData.data.set(visualData);
      ctx.putImageData(imageData, 0, 0);
      const quantizedImage = document.getElementById('quantizedImage');
      quantizedImage.src = canvas.toDataURL();
      quantizedImage.style.display = 'block';
    });

    // ç‚¹å‡»å ä½ç¬¦æˆ–æ–‡å­—åŒºåŸŸæ—¶è§¦å‘æ–‡ä»¶é€‰æ‹©
    document.querySelector('.preview-box').addEventListener('click', () => {
      console.log('ç‚¹å‡»äº†é¢„è§ˆæ¡†');
      document.getElementById('imageInput').click();
    });

    // æ–‡ä»¶é€‰æ‹©åæ˜¾ç¤ºé¢„è§ˆ
    document.getElementById('imageInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = document.getElementById('previewImage');
        img.src = e.target.result;
        img.style.display = 'block';

        // éšè—åŸå›¾çš„ placeholder
        const box = img.closest('.preview-box');
        const placeholder = box.querySelector('.placeholder');
        if (placeholder) placeholder.style.display = 'none';
      };
      reader.readAsDataURL(file);
    });

    //document.querySelector('form').addEventListener('submit', function (event) {
    document.getElementById('scanBLEBtn').addEventListener('click', () => {
      event.stopPropagation();
      event.preventDefault();

      if (isWebBluetoothEnabled()) {
        console.clear();
        startBle();
      }
    });

    document.getElementById('setWifiBtn').addEventListener('click', async () => {
      const ssid = document.getElementById('ssid').value;
      const password = document.getElementById('password').value;

      if (!ssid || !password) {
        alert("è¯·å…ˆè¾“å…¥å®Œæ•´çš„ SSID å’Œå¯†ç ");
        return;
      }

      console.log(`å¼€å§‹è®¾ç½®WiFi: ${ssid} / ${password}`);

      try {
        const encoder = new TextEncoder();
        const ssidUint8 = encoder.encode(ssid);
        const pwdUint8 = encoder.encode(password);

        // åè®®æ ¼å¼: [CMD] [SSID_LEN] [PWD_LEN] [SSID_DATA] [PWD_DATA]
        // æ€»é•¿åº¦ = 1 (å‘½ä»¤) + 1 (SSIDé•¿) + 1 (å¯†ç é•¿) + SSIDå†…å®¹é•¿åº¦ + å¯†ç å†…å®¹é•¿åº¦
        const totalLen = 1 + 1 + 1 + ssidUint8.length + pwdUint8.length;
        const cmdFrame = new Uint8Array(totalLen);

        // å¡«å……æ•°æ®
        cmdFrame[0] = 0x08; // CMD_SET_WIFI (å‡è®¾ä¸º 0x08)
        cmdFrame[1] = ssidUint8.length; // SSID é•¿åº¦
        cmdFrame[2] = pwdUint8.length; // å¯†ç é•¿åº¦

        // æ‹·è´å†…å®¹
        cmdFrame.set(ssidUint8, 3); // ä»ç´¢å¼• 3 å¼€å§‹å­˜ SSID
        cmdFrame.set(pwdUint8, 3 + ssidUint8.length); // ç´§æ¥ç€å­˜å¯†ç 

        // å‘é€ BLE å‘½ä»¤
        if (bleState.ch_tx) {
          await bleState.ch_tx.writeValue(cmdFrame);
          log(`âœ… WiFi æŒ‡ä»¤å‘é€æˆåŠŸ (${totalLen} å­—èŠ‚)`);
        } else {
          throw new Error("è“ç‰™æœªè¿æ¥æˆ–ç‰¹å¾å€¼ä¸å¯ç”¨");
        }

      } catch (error) {
        log(`âŒ WiFi æŒ‡ä»¤å‘é€å¤±è´¥: ${error.message}`);
        console.error(error);
      }
    });

    document.getElementById('getIPBtn').addEventListener('click', async () => {
      try {
        const payload = new Uint8Array(1);
        payload[0] = EPD_CMD.CMD_SET_WIFI;

        await bleState.ch_tx.writeValueWithResponse(payload);
        log("âœ… å‘é€æˆåŠŸ");

        // è¯»å– IP åœ°å€
        const value = await withTimeout(bleState.ch_rx.readValue(), 5000, 'è¯»å–IP');
        log(`IP åœ°å€: ${value}`);

        // 3. è§£ç  DataView ä¸º å­—ç¬¦ä¸²
        const decoder = new TextDecoder('utf-8');
        const ipString = decoder.decode(value);

        if (ipString === "0.0.0.0") {
          log(`âš ï¸ å°šæœªè·å–åˆ° IPï¼Œè¯·æ£€æŸ¥ WiFi æ˜¯å¦è¿æ¥æˆåŠŸ (å½“å‰: ${ipString})`);
        } else {
          log(`ğŸŒ è·å–æˆåŠŸ! IP åœ°å€: ${ipString}`);
          document.getElementById('ipAddress').value = ipString;
        }

      } catch (error) {
        log(`âŒ å‘é€å¤±è´¥: ${error}`);
        console.error(error);
      }
    });

    document.getElementById('setdeviceBtn').addEventListener('click', async () => {
      const modelName = document.getElementById('modelSet').value.trim();

      if (!modelName) {
        alert("è¯·å…ˆç¡®ä¿å‹å·ä¿¡æ¯å·²è¯»å–ï¼ˆå‹å·ï¼‰");
        return;
      }

      try {

        const encoder = new TextEncoder();
        const nameBytes = encoder.encode(modelName);

        // 3. æ„å»ºå‘é€ç¼“å†²åŒº: [CMD(1å­—èŠ‚), ...åç§°å­—èŠ‚]
        // æ³¨æ„ï¼šå¦‚æœä½ åœ¨ ESP32 ä»£ç ä¸­ä½¿ç”¨ (const char *)param->write.value + 1
        // é‚£ä¹ˆä½ çš„è“ç‰™åŒ…å¿…é¡»ä¸€æ¬¡æ€§å‘å®Œï¼ˆæˆ–è€…ç¡®ä¿åˆ†åŒ…é€»è¾‘æ­£ç¡®ï¼‰
        const payload = new Uint8Array(1 + nameBytes.length);
        payload[0] = EPD_CMD.CMD_SET_EPD_NAME;
        payload.set(nameBytes, 1);

        log(`ğŸ“¡ æ­£åœ¨å‘é€å‹å·è®¾ç½®: ${modelName} (å…± ${payload.length} å­—èŠ‚)`);

        // 4. é€šè¿‡ Web Bluetooth å†™å…¥ç‰¹å¾å€¼
        // ä½¿ç”¨ writeValueWithResponse ç¡®ä¿å†™å…¥æˆåŠŸï¼ˆä¼šç­‰å¾…å›å¤ï¼Œæ›´ç¨³å®šï¼‰
        await bleState.ch_tx.writeValueWithResponse(payload);

        log("ğŸ“¨ æŒ‡ä»¤å·²é€è¾¾ï¼Œç­‰å¾…ç¡¬ä»¶ä¿å­˜ç»“æœ...");
      } catch (error) {
        log(`âŒ å‘é€å¤±è´¥: ${error}`);
        console.error(error);
      }
    });

    document.getElementById('setModeBtn').addEventListener('click', async () => {
      const modeStr = document.getElementById('woringModeSet').value;
      if (!modeStr) {
        alert("è¯·å…ˆè¾“å…¥å·¥ä½œæ¨¡å¼");
        return;
      }
      const modeInt = parseInt(modeStr);

      log(`å½“å‰é€‰æ‹©çš„å·¥ä½œæ¨¡å¼: ${modeInt}`);

      try {
        const payload = new Uint8Array(2);
        payload[0] = EPD_CMD.CMD_SET_WORKING_MODE;
        payload[1] = modeInt; // è¿™é‡Œç›´æ¥å­˜å…¥æ•°å­— 0 æˆ– 1ï¼Œè€Œä¸æ˜¯å­—ç¬¦ç 
        log(`ğŸ“¡ æ­£åœ¨å‘é€å·¥ä½œæ¨¡å¼è®¾ç½®: ${modeInt} (åå…­è¿›åˆ¶: 0x${payload[0].toString(16)}, 0x${payload[1].toString(16)})`);

        await bleState.ch_tx.writeValueWithResponse(payload);
        log("âœ… å‘é€æˆåŠŸ");
      } catch (error) {
        log(`âŒ å‘é€å¤±è´¥: ${error}`);
        console.error(error);
      }
    });

    document.getElementById('ClearBtn').addEventListener('click', async () => {
      if (!bleState.ch_tx) {
        alert("è“ç‰™æœªè¿æ¥ï¼");
        return;
      }

      try {
        // æ„é€ å‘½ä»¤æ•°æ®åŒ…ï¼šbyte1 ä¸ºæ¸…å±æŒ‡ä»¤ 0x06ï¼Œbyte2 ä¸ºé¢œè‰²ç´¢å¼•
        const clearCmd = new Uint8Array(2);
        clearCmd[0] = EPD_CMD.CMD_EPD_CLEAR; // 0x06
        clearCmd[1] = selectedPaletteIndex; // é€‰ä¸­çš„ç´¢å¼•å€¼

        log(`ğŸ“¡ å‘é€æ¸…å±æŒ‡ä»¤: CMD=0x06, ColorIndex=${selectedPaletteIndex}`);

        // é€šè¿‡ FF05 ç‰¹å¾å€¼å‘é€
        await bleState.ch_tx.writeValue(clearCmd);
        log("âœ… æ¸…å±æŒ‡ä»¤å‘é€æˆåŠŸ");
      } catch (error) {
        log(`âŒ æ¸…å±æŒ‡ä»¤å‘é€å¤±è´¥: ${error.message}`);
      }
    });

    document.getElementById('exportBinBtn').addEventListener('click', () => {
      if (!outputData || outputData.length === 0) {
        alert("è¯·å…ˆè¿›è¡Œå›¾ç‰‡é‡åŒ–ï¼");
        return;
      }

      // åˆ›å»º Blob å¯¹è±¡
      const blob = new Blob([outputData], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);

      // åˆ›å»ºéšè—çš„ä¸‹è½½é“¾æ¥
      const a = document.createElement('a');
      a.href = url;
      a.download = `image_${document.getElementById('width').value}x${document.getElementById('height').value}.bin`;
      document.body.appendChild(a);
      a.click();

      // æ¸…ç†
      setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }, 0);

      console.log("âœ… BINæ–‡ä»¶å·²å¯¼å‡º");
    });

    // è§¦å‘æ–‡ä»¶é€‰æ‹©
    document.getElementById('importBinBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    // å¤„ç†æ–‡ä»¶è¯»å–ä¸åå‘æ¸²æŸ“
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const buffer = await file.arrayBuffer();
      const importedData = new Uint8Array(buffer);

      const w = parseInt(document.getElementById('width').value);
      const h = parseInt(document.getElementById('height').value);
      const colorCount = devicePalette.length;

      if (!w || !h || colorCount === 0) {
        alert("è¯·å…ˆç¡®ä¿è®¾å¤‡ä¿¡æ¯å·²è¯»å–ï¼ˆå®½/é«˜/è°ƒè‰²æ¿ï¼‰");
        return;
      }

      console.log(`å¼€å§‹è¿˜åŸ: ${importedData.length} å­—èŠ‚ -> ${w}x${h} å›¾åƒ`);

      // 1. åˆ›å»ºç”¨äºæ˜¾ç¤ºçš„ Canvas
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(w, h);
      const rgba = imageData.data;

      // 2. åå‘è§£ç é€»è¾‘ (Unpacking)
      for (let i = 0; i < w * h; i++) {
        let paletteIndex = 0;

        if (colorCount <= 2) {
          // 1bpp è¿˜åŸ
          const byte = importedData[Math.floor(i / 8)];
          const bitShift = 7 - (i % 8);
          paletteIndex = (byte >> bitShift) & 0x01;
        }
        else if (colorCount <= 4) {
          // 2bpp è¿˜åŸ
          const byte = importedData[Math.floor(i / 4)];
          const bitShift = (3 - (i % 4)) * 2;
          paletteIndex = (byte >> bitShift) & 0x03;

          // 3è‰²å±ç‰¹æ®Šæ˜ å°„è¿˜åŸ (0b11 -> ç´¢å¼•2)
          if (colorCount === 3 && paletteIndex === 3) paletteIndex = 2;
        }
        else {
          // 4bpp è¿˜åŸ
          const byte = importedData[Math.floor(i / 2)];
          const bitShift = (1 - (i % 2)) * 4;
          paletteIndex = (byte >> bitShift) & 0x0F;
        }

        // 3. ä»è°ƒè‰²æ¿å–è‰²å¹¶å¡«å…¥ RGBA æ•°ç»„
        const rgb = devicePalette[paletteIndex] || [0, 0, 0];
        const offset = i * 4;
        rgba[offset] = rgb[0]; // R
        rgba[offset + 1] = rgb[1]; // G
        rgba[offset + 2] = rgb[2]; // B
        rgba[offset + 3] = 255; // A (ä¸é€æ˜)
      }

      // 4. å°†è¿˜åŸåçš„å›¾åƒæ˜¾ç¤ºåˆ°é¡µé¢
      ctx.putImageData(imageData, 0, 0);
      const quantizedImage = document.getElementById('quantizedImage');
      quantizedImage.src = canvas.toDataURL();
      quantizedImage.style.display = 'block';

      log("âœ… å›¾åƒåå‘è¿˜åŸæˆåŠŸ");
    });
  </script>
</body>

</html>